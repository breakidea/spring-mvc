package org.ionnic.common.support.view.tool;import java.net.URLEncoder;import java.security.MessageDigest;import java.util.Map;import org.ionnic.common.Config;import org.ionnic.common.util.JsonUtils;import org.springframework.util.StringUtils;/** * @author apple * */public class StringTool extends StringUtils {    /**     * Converts the specified Unicode code point and/or escape sequence into     * the associated Unicode character.  This allows numeric     * code points or String versions of the numeric code point to be correctly     * translated within a template.  This is especially useful for those     * creating unicode from a reference value, or injecting a unicode character     * into a template with a version of Velocity prior to 1.6.     * @param code the code to be translated/escaped, may be null     * @return the unicode character for that code, {@code null} if input was null     * @see Character#toChars(int codePoint)     */    public String unicode(Object code) {        if (code == null) {            return null;        }        String s = String.valueOf(code);        if (s.startsWith("\\u")) {            s = s.substring(2, s.length());        }        int codePoint = Integer.valueOf(s, 16);        return String.valueOf(Character.toChars(codePoint));    }    /**     * @param s     * @return     */    public static String encrypt(String s) {        char hexDigits[] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };        try {            byte[] strTemp = s.getBytes();            MessageDigest mdTemp = MessageDigest.getInstance("MD5");            mdTemp.update(strTemp);            byte[] md = mdTemp.digest();            int j = md.length;            char str[] = new char[j * 2];            int k = 0;            for (int i = 0; i < j; i++) {                byte byte0 = md[i];                str[k++] = hexDigits[byte0 >>> 4 & 0xf];                str[k++] = hexDigits[byte0 & 0xf];            }            return new String(str);        } catch (Exception e) {            return "";        }    }    /**     * HTML编码     *     * @param {String} source     * @return     */    public static String escapeInH(Object subject) {        if (null == subject) {            return "";        } else {            String source = subject.toString();            source = source.replaceAll("\\&", "&amp;");            source = source.replaceAll("\\\"", "&quot;");            source = source.replaceAll("\\<", "&lt;");            source = source.replaceAll("\\>", "&gt;");            return source;        }    }    /**     * @param subject     * @return     */    public static String escapeInHJ(Object subject) {        return escapeInH(escapeInJ(subject));    }    /**     * 在普通JS环境需要将影响JS语法环境的字符串转义     *     * @public     * @param {String} source 原始字符串     * @return string     */    public static String escapeInJ(Object subject) {        if (null == subject) {            return "";        } else {            StringBuffer buffer = new StringBuffer();            String source = subject.toString();            int length = source.length();            for (int i = 0; i < length; i++) {                char c = source.charAt(i);                switch (c) {                    case 39:                        buffer.append("\\'");                        break;                    case 34:                        buffer.append("\\\"");                        break;                    case 47:                        buffer.append("\\/");                        break;                    case 92:                        buffer.append("\\\\");                        break;                    case 13:                        buffer.append("\\r");                        break;                    case 10:                        buffer.append("\\n");                        break;                    default:                        buffer.append(c);                        break;                }            }            return buffer.toString();        }    }    /**     * 编码 URL 字符串     *     * @param {String} string     * @return string     */    public static String escapeInU(Object subject) {        String string = trim(subject);        String decoded = null;        try {            decoded = URLEncoder.encode(string, Config.CHARSET);            return decoded.replaceAll("\\+", "%20");        } catch (Exception e) {        }        return string;    }    /**     * @param json     * @return     */    public static Map<String, Object> parse(String json) {        try {            return JsonUtils.fromJson(json);        } catch (Exception e) {        }        return null;    }    /**     * @param subject     * @return     */    public static String raw(Object subject) {        if (subject == null) {            return "";        } else {            return subject.toString();        }    }    /**     * 从字符串中去除 HTML标记     *     * @public     * @param {String} html     * @return text     */    public static String stripTags(Object subject) {        if (null == subject) {            return "";        }        String source = subject.toString();        return source.replaceAll("\\<.*?>", "");    }    /**     * @param source     * @return     */    public static String toJson(Object source) {        try {            return JsonUtils.toJson(source);        } catch (Exception e) {            return null;        }    }    /**     * trim 字符串函数     *     * @public     * @param {String} source     * @return     */    public static String trim(Object source) {        if (null == source) {            return "";        }        return (source + "").trim();    }}