package org.ionnic.core.support;import java.io.IOException;import java.io.UnsupportedEncodingException;import java.util.Locale;import javax.servlet.FilterChain;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletRequestWrapper;import javax.servlet.http.HttpServletResponse;import org.ionnic.core.support.filter.FilterConfig;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.context.support.ClassPathXmlApplicationContext;import org.springframework.util.StringUtils;import org.springframework.web.filter.GenericFilterBean;public class Filter extends GenericFilterBean {	Logger logger = LoggerFactory.getLogger(Filter.class);	public static String PARAMETER_NAME = "configLocation";	private FilterConfig config;	@Override	public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {		request.setAttribute("filter", config.getClass().getName());		doCharsetEncoding((HttpServletRequest) request, (HttpServletResponse) response);		doHiddenHttpMethod((HttpServletRequest) request, (HttpServletResponse) response, chain);	}	/**	 * @param request	 * @param response	 * @throws UnsupportedEncodingException	 */	private void doCharsetEncoding(HttpServletRequest request, HttpServletResponse response) throws UnsupportedEncodingException {		if (config.getEncoding() != null && (config.isForceEncoding() || request.getCharacterEncoding() == null)) {			request.setCharacterEncoding(config.getEncoding());			if (config.isForceEncoding()) {				response.setCharacterEncoding(config.getEncoding());			}			if (logger.isDebugEnabled()) {				logger.debug("set charsetEncoding as " + config.getEncoding() + "request is " + request.getRequestURI());			}		}	}	/**	 * @param request	 * @param response	 * @param filterChain	 * @throws ServletException	 * @throws IOException	 */	private void doHiddenHttpMethod(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException,	        IOException {		if (!config.isIgnoreHiddenMethod()) {			String paramValue = request.getParameter(config.getHiddenMethodParam());			if ("POST".equals(request.getMethod()) && StringUtils.hasLength(paramValue)) {				String method = paramValue.toUpperCase(Locale.ENGLISH);				HttpServletRequest wrapper = new HttpMethodRequestWrapper(request, method);				if (logger.isDebugEnabled()) {					logger.debug("set HiddenHttpMethod to " + method + ", request is " + request.getRequestURI());				}				request.setAttribute("method", method);				filterChain.doFilter(wrapper, response);			} else {				filterChain.doFilter(request, response);			}		} else {			filterChain.doFilter(request, response);		}	}	@Override	protected void initFilterBean() throws ServletException {		// TODO Auto-generated method stub		if (null == config) {			String configLocation = this.getFilterConfig().getInitParameter(PARAMETER_NAME);			if (logger.isDebugEnabled()) {				logger.debug("Initializing config '" + configLocation + "'");			}			config = (FilterConfig) new ClassPathXmlApplicationContext(configLocation).getBean("internalFilter");		}	}}class HttpMethodRequestWrapper extends HttpServletRequestWrapper {	private final String method;	/**	 * @param request	 * @param method	 */	public HttpMethodRequestWrapper(HttpServletRequest request, String method) {		super(request);		this.method = method;	}	@Override	public String getMethod() {		return this.method;	}}